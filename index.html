<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Modbus Logger Documentation | Hng Jesse</title>
  <style>
    body {
        background-color: #0d1117;  /* GitHub dark mode background */
        color: #c9d1d9;             /* GitHub text color */
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 40px auto;
        line-height: 1.6;
    }
    a {
      color: #58a6ff;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    h1, h2, h3 {
      color: #ffffff;
    }
    header, footer {
      text-align: center;
    }
    hr {
      border: 0;
      border-top: 1px solid #30363d;
      margin: 30px 0;
    }
    pre {
      background-color: #161b22;
      border: 1px solid #30363d;
      padding: 12px;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 0.9rem;
      color: #c9d1d9;
    }
    code {
      background-color: #21262d;
      color: #c9d1d9;
      padding: 2px 5px;
      border-radius: 4px;
      font-family: monospace;
    }
    ul {
      margin-left: 20px;
    }
    p {
      text-align: justify;
    }

    @media (max-width: 768px) {
      body {
        background-color: #0d1117;  /* GitHub dark mode background */
        color: #c9d1d9;             /* GitHub text color */
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 40px auto;
        line-height: 1.6;
      }
      a {
        color: #58a6ff;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      h1, h2, h3 {
        color: #ffffff;
      }
      header, footer {
        text-align: center;
      }
      hr {
        border: 0;
        border-top: 1px solid #30363d;
        margin: 30px 0;
      }
      pre {
        background-color: #161b22;
        border: 1px solid #30363d;
        padding: 12px;
        border-radius: 8px;
        overflow-x: auto;
        font-size: 0.9rem;
        color: #c9d1d9;
      }
      code {
        background-color: #21262d;
        color: #c9d1d9;
        padding: 2px 5px;
        border-radius: 4px;
        font-family: monospace;
      }
      ul {
        margin-left: 20px;
      }
      p {
        text-align: justify;
      }
    }




  </style>
</head>
<body>
  <header>
    <h1>Modbus Logger Documentation</h1>
    <nav>by <strong>Hng Jesse</strong></nav>
    <nav>
      <a href="https://github.com/hngjesse/Modbus_loggers" target="_blank">GitHub Repository</a> |
      <a href="https://hngjesse.github.io/" target="_blank">Homepage</a>
    </nav>
    <hr>
  </header>

  <main>
    <section>
      <h2>Introduction</h2>
      <p>
        This project addresses common challenges encountered in data logging using the 
        <a href="https://en.wikipedia.org/wiki/Modbus" target="_blank">Modbus</a> communication protocol.
        Modbus was introduced in 1979 by <strong>Modicon</strong> (now Schneider Electric) to standardize 
        communication between industrial electronic devices. It defines a universal protocol that allows 
        different devices to exchange data reliably. Since 2004, the protocol has been maintained by the 
        <strong>Modbus Organization, Inc.</strong>
      </p>
      <p>
        One classification of Modbus communication is the <strong>Master–Slave</strong> model, also known as 
        <strong>Modbus RTU (Remote Terminal Unit)</strong>. In this model, the master device initiates commands 
        to request data from one or more slave devices. Slaves only respond when queried by the master. 
        Typically, Modbus RTU operates over <strong>RS-485</strong> or <strong>RS-232</strong> serial connections 
        and supports one master with multiple slaves.
      </p>
      <p>
        Another type is the <strong>Client–Server</strong> model, referred to as <strong>Modbus TCP</strong>. 
        Here, communication occurs over Ethernet or a local network. Although conceptually similar to the 
        master–slave architecture, Modbus TCP allows multiple clients and servers to communicate simultaneously, 
        enhancing scalability and flexibility.
      </p>
      <p>
        Modbus supports several <strong>function codes</strong>, each representing a different type of request:
      </p>
      <ul>
        <li>Function Code 01 — <strong>Read Coils</strong></li>
        <li>Function Code 02 — <strong>Read Discrete Inputs</strong></li>
        <li>Function Code 03 — <strong>Read Holding Registers</strong></li>
        <li>Function Code 04 — <strong>Read Input Registers</strong></li>
      </ul>
      <p>
        Depending on the type of data required, the user selects the appropriate function code to retrieve information 
        from a Modbus device.
      </p>
    </section>

    <hr>

    <section>
      <h2>Coding and File Structure</h2>
      <p>
        The main working directory of this Python project is <code>Modbus_loggers</code>. It contains three key subdirectories:
      </p>
      <ul>
        <li><code>configs</code></li>
        <li><code>data_storage</code></li>
        <li><code>utils</code></li>
      </ul>
      <p>
        The core script, <code>modbus_logger.py</code>, is located in the <code>Modbus_loggers</code> directory. 
        This script provides the foundational structure for the entire data logging system. It defines the main 
        workflow and executes essential functions sequentially or in a continuous loop. 
        <strong>Users are not advised to modify this file</strong> unless they fully understand its internal logic.
      </p>
    </section>

    <hr>

    <section>
      <h2>Configuration JSON File</h2>
      <p>
        The <code>configs</code> subdirectory contains JSON configuration files that define communication 
        and logging parameters for each Modbus device.
      </p>

      <h3>Example: Modbus RTU Configuration</h3>
      <pre><code>{
  "modbus": {
    "type": "serial",
    "timeout": 0.2,
    "port": "/dev/ttyS0",
    "baudrate": 19200,
    "stopbits": 1,
    "bytesize": 8,
    "parity": "N"
  },
  "device": {
    "name": "dcm_3366",
    "start_addr": 0,
    "reg_count": 40,
    "id_range": [1,2,3,4,5,6,7,8]
  },
  "logging": {
    "base_folder": "/mnt/data_storage/Modbus_loggers/data_storage/dcm_3366",
    "log_retention_days": 30,
    "file_suffix": "dcm_3366",
    "header": ["Datetime", "Device_ID",
    "Forward_energy_kWh", "Active_power_kW",
    "Current_A", "Voltage_V", "Error"],
    "time_step": 2
  }
}</code></pre>

      <h3>Example: Modbus TCP Configuration</h3>
      <pre><code>{
  "modbus": {
    "type": "tcp",
    "timeout": 0.2,
    "host": "192.168.1.10",
    "port": 502
  },
  "device": {
    "name": "list_regis",
    "start_addr": 4096,
    "reg_count": 125,
    "id_range": [1]
  },
  "logging": {
    "base_folder": "/mnt/data_storage/Modbus_loggers/data_storage/list_regis",
    "log_retention_days": 30,
    "file_suffix": "regis",
    "header": ["Datetime", "Device_ID"],
    "time_step": 2
  }
}</code></pre>

      <h3>Parameter Explanation</h3>
      <p><strong>Modbus Section:</strong></p>
      <ul>
        <li><code>type</code>: Connection type — <code>"serial"</code> (RTU) or <code>"tcp"</code>.</li>
        <li><code>timeout</code>: Maximum time (seconds) to wait for a device response.</li>
        <li><code>port</code>: Serial port (e.g., <code>/dev/ttyS0</code>) or TCP port number.</li>
        <li>Other parameters define serial communication settings or TCP host configuration.</li>
      </ul>

      <p><strong>Device Section:</strong></p>
      <ul>
        <li><code>name</code>: Corresponds to a device-specific function in <code>utils</code>.</li>
        <li><code>start_addr</code>: Starting register address.</li>
        <li><code>reg_count</code>: Number of registers to read.</li>
        <li><code>id_range</code>: List of Modbus device IDs to poll.</li>
      </ul>

      <p><strong>Logging Section:</strong></p>
      <ul>
        <li><code>base_folder</code>: Directory for log files.</li>
        <li><code>log_retention_days</code>: How long logs are retained.</li>
        <li><code>file_suffix</code>: Label for filenames.</li>
        <li><code>header</code>: Defines CSV structure.</li>
        <li><code>time_step</code>: Logging interval in seconds.</li>
      </ul>
    </section>

    <hr>

    <section>
      <h2>Utilities Folder</h2>
      <p>
        The <code>utils</code> directory includes:
      </p>
      <ul>
        <li><code>__init__.py</code></li>
        <li><code>common_utils.py</code></li>
        <li><code>validate_config.py</code></li>
        <li><code>device_specific_func.py</code></li>
      </ul>
      <p>
        <code>common_utils.py</code> provides helper functions used by the main script.
        <code>validate_config.py</code> verifies JSON files for formatting or logical errors.
        The <code>device_specific_func.py</code> file is where users can define custom functions for their Modbus devices.<br>
        This modular approach allows users to log data from different devices by simply writing their own device-specific function 
        without modifying the main logging structure.
      </p>

      <h3>Example Device-Specific Function</h3>
      <pre><code class="language-python">
import struct
import csv
import logging
from datetime import datetime
from pymodbus.client import ModbusSerialClient, ModbusTcpClient

logger = logging.getLogger(__name__)

def dcm_3366(client: ModbusSerialClient, start_addr: int, reg_count: int,
             csv_file: str, device_range: range) -> None:
    """Read DC meter (DCM3366) and save readings."""
    for device_id in device_range:
        logger.info(f"[dcm_3366] Reading device with Modbus ID = {device_id} ...")

        try:
            response = client.read_holding_registers(
                address=start_addr, count=reg_count, device_id=device_id
            )
        except Exception as e:
            logger.error(f"Error reading device {device_id}: {e}")
            now = datetime.now().isoformat()
            with open(csv_file, "a", newline="") as f:
                csv.writer(f).writerow([now, device_id, None, None, None, None, "Error"])
            continue

        regs = response.registers
        Forward_energy = (regs[0] << 16) + regs[1]
        Active_power = (regs[20] << 16) + regs[21]
        Current = (regs[22] << 16) + regs[23]
        Voltage = (regs[24] << 16) + regs[25]
        now = datetime.now().isoformat()

        with open(csv_file, "a", newline="") as f:
            csv.writer(f).writerow([
                now, device_id,
                round(Forward_energy / 100, 3),
                round(Active_power / 1000, 3),
                round(Current / 10000, 3),
                round(Voltage / 10000, 1),
                "No error"
            ])
</code></pre>
    <hr>
    </section>
        <article>
            <h3>Other GitHub Projects</h3>
            <p>
                Full project available on GitHub: 
                <a href="https://github.com/hngjesse" target="_blank">
                    https://github.com/hngjesse
                </a>
            </p>
        </article>
    </section>
    <hr>
    <section id="contact">
        <h2>Contact</h2>
        <p>
            📧 Email: <a href="mailto:hngjesse@gmail.com">hngjesse@gmail.com</a><br>
            🔗 GitHub: <a href="https://github.com/hngjesse" target="_blank">hngjesse</a>
        </p>
    </section>
  </main>

  <footer>
    <hr>
    <p>© 2025 Hng Jesse — Published via GitHub Pages</p>
  </footer>
</body>
</html>
